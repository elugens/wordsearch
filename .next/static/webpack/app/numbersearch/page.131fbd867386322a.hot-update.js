"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/numbersearch/page",{

/***/ "(app-pages-browser)/./src/lib/numberSearchGenerator.ts":
/*!******************************************!*\
  !*** ./src/lib/numberSearchGenerator.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateNumberSearch: function() { return /* binding */ generateNumberSearch; }\n/* harmony export */ });\nfunction generateRandomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction generateEquation(targetNumber, complexity) {\n    switch(complexity){\n        case \"easy\":\n            // Simple addition or subtraction\n            if (Math.random() > 0.5 && targetNumber > 2) {\n                const num1 = generateRandomNumber(1, targetNumber - 1);\n                return {\n                    equation: \"\".concat(num1, \" + \").concat(targetNumber - num1, \" = ?\"),\n                    result: targetNumber\n                };\n            } else {\n                const num1 = generateRandomNumber(targetNumber + 1, targetNumber + 10);\n                return {\n                    equation: \"\".concat(num1, \" - \").concat(num1 - targetNumber, \" = ?\"),\n                    result: targetNumber\n                };\n            }\n        case \"medium\":\n            // Multiplication or division\n            if (Math.random() > 0.5) {\n                const factor = generateRandomNumber(2, 5);\n                return {\n                    equation: \"\".concat(targetNumber, \" \\xd7 \").concat(factor, \" = ?\"),\n                    result: targetNumber * factor\n                };\n            } else {\n                const factor = generateRandomNumber(2, 5);\n                const product = targetNumber * factor;\n                return {\n                    equation: \"\".concat(product, \" \\xf7 \").concat(factor, \" = ?\"),\n                    result: targetNumber\n                };\n            }\n        case \"hard\":\n            // Mixed operations\n            const operations = [\n                \"+\",\n                \"-\",\n                \"\\xd7\"\n            ];\n            const op = operations[Math.floor(Math.random() * operations.length)];\n            const num1 = generateRandomNumber(1, 10);\n            const num2 = generateRandomNumber(1, 10);\n            switch(op){\n                case \"+\":\n                    return {\n                        equation: \"(\".concat(num1, \" \\xd7 \").concat(num2, \") + \").concat(targetNumber - num1 * num2, \" = ?\"),\n                        result: targetNumber\n                    };\n                case \"-\":\n                    return {\n                        equation: \"(\".concat(num1, \" \\xd7 \").concat(num2, \") - \").concat(num1 * num2 - targetNumber, \" = ?\"),\n                        result: targetNumber\n                    };\n                case \"\\xd7\":\n                    if (targetNumber % num1 === 0) {\n                        return {\n                            equation: \"\".concat(targetNumber / num1, \" \\xd7 \").concat(num1, \" =\"),\n                            result: targetNumber\n                        };\n                    } else {\n                        return {\n                            equation: \"\".concat(num1, \" \\xd7 \").concat(num2, \" + \").concat(targetNumber - num1 * num2, \" = ?\"),\n                            result: targetNumber\n                        };\n                    }\n            }\n    }\n    // Fallback simple equation\n    return {\n        equation: \"? = \".concat(targetNumber),\n        result: targetNumber\n    };\n}\nfunction canPlaceNumber(grid, number, row, col, direction) {\n    const numLength = number.length;\n    const [dRow, dCol] = direction;\n    const size = grid.length;\n    // Check if the number fits within the grid bounds\n    if (row + dRow * (numLength - 1) >= size || row + dRow * (numLength - 1) < 0 || col + dCol * (numLength - 1) >= size || col + dCol * (numLength - 1) < 0) {\n        return false;\n    }\n    // Check if the cells are empty\n    for(let i = 0; i < numLength; i++){\n        if (grid[row + dRow * i][col + dCol * i] !== \"\") {\n            return false;\n        }\n    }\n    return true;\n}\nfunction placeNumber(grid, number, row, col, direction) {\n    const [dRow, dCol] = direction;\n    const digits = number.split(\"\");\n    digits.forEach((digit, i)=>{\n        grid[row + dRow * i][col + dCol * i] = digit;\n    });\n}\nfunction getDirections(complexity) {\n    const directions = [\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            0\n        ]\n    ];\n    if (complexity === \"medium\" || complexity === \"hard\") {\n        directions.push([\n            1,\n            1\n        ], [\n            -1,\n            1\n        ] // diagonal up-right\n        );\n    }\n    return directions;\n}\nfunction generateNumberSearch(param) {\n    let { size = 15, minNumber = 1, maxNumber = 999, numbersToFind = 8, complexity = \"medium\", includeEquations = false } = param;\n    // Initialize empty grid\n    const grid = Array(size).fill(null).map(()=>Array(size).fill(\"\"));\n    // Generate random numbers\n    const numbers = [];\n    const equations = [];\n    while(numbers.length < numbersToFind){\n        const num = generateRandomNumber(minNumber, maxNumber);\n        if (!numbers.includes(num)) {\n            numbers.push(num);\n            if (includeEquations) {\n                equations.push(generateEquation(num, complexity));\n            }\n        }\n    }\n    // Sort numbers for consistent difficulty\n    numbers.sort((a, b)=>b.toString().length - a.toString().length);\n    const directions = getDirections(complexity);\n    // Place numbers in the grid\n    numbers.forEach((number)=>{\n        const numStr = number.toString();\n        let placed = false;\n        let attempts = 0;\n        const maxAttempts = size * size;\n        while(!placed && attempts < maxAttempts){\n            const row = Math.floor(Math.random() * size);\n            const col = Math.floor(Math.random() * size);\n            const direction = directions[Math.floor(Math.random() * directions.length)];\n            if (canPlaceNumber(grid, numStr, row, col, direction)) {\n                placeNumber(grid, numStr, row, col, direction);\n                placed = true;\n            }\n            attempts++;\n        }\n        if (!placed) {\n            console.warn(\"Could not place number \".concat(number));\n        }\n    });\n    // Fill empty cells with random digits\n    for(let i = 0; i < size; i++){\n        for(let j = 0; j < size; j++){\n            if (grid[i][j] === \"\") {\n                grid[i][j] = Math.floor(Math.random() * 10).toString();\n            }\n        }\n    }\n    return {\n        grid,\n        numbers,\n        equations: includeEquations ? equations : undefined\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbnVtYmVyU2VhcmNoR2VuZXJhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFjQSxTQUFTQSxxQkFBcUJDLEdBQVcsRUFBRUMsR0FBVztJQUNwRCxPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBTUgsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtBQUN2RDtBQUVBLFNBQVNLLGlCQUFpQkMsWUFBb0IsRUFBRUMsVUFBc0M7SUFDcEYsT0FBUUE7UUFDTixLQUFLO1lBQ0gsaUNBQWlDO1lBQ2pDLElBQUlMLEtBQUtFLE1BQU0sS0FBSyxPQUFPRSxlQUFlLEdBQUc7Z0JBQzNDLE1BQU1FLE9BQU9ULHFCQUFxQixHQUFHTyxlQUFlO2dCQUNwRCxPQUFPO29CQUNMRyxVQUFVLEdBQWFILE9BQVZFLE1BQUssT0FBeUIsT0FBcEJGLGVBQWVFLE1BQUs7b0JBQzNDRSxRQUFRSjtnQkFDVjtZQUNGLE9BQU87Z0JBQ0wsTUFBTUUsT0FBT1QscUJBQXFCTyxlQUFlLEdBQUdBLGVBQWU7Z0JBQ25FLE9BQU87b0JBQ0xHLFVBQVUsR0FBYUQsT0FBVkEsTUFBSyxPQUF5QixPQUFwQkEsT0FBT0YsY0FBYTtvQkFDM0NJLFFBQVFKO2dCQUNWO1lBQ0Y7UUFFRixLQUFLO1lBQ0gsNkJBQTZCO1lBQzdCLElBQUlKLEtBQUtFLE1BQU0sS0FBSyxLQUFLO2dCQUN2QixNQUFNTyxTQUFTWixxQkFBcUIsR0FBRztnQkFDdkMsT0FBTztvQkFDTFUsVUFBVSxHQUFxQkUsT0FBbEJMLGNBQWEsVUFBWSxPQUFQSyxRQUFPO29CQUN0Q0QsUUFBUUosZUFBZUs7Z0JBQ3pCO1lBQ0YsT0FBTztnQkFDTCxNQUFNQSxTQUFTWixxQkFBcUIsR0FBRztnQkFDdkMsTUFBTWEsVUFBVU4sZUFBZUs7Z0JBQy9CLE9BQU87b0JBQ0xGLFVBQVUsR0FBZ0JFLE9BQWJDLFNBQVEsVUFBWSxPQUFQRCxRQUFPO29CQUNqQ0QsUUFBUUo7Z0JBQ1Y7WUFD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QUFVLENBQUNoQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSzhCLFdBQVduQixNQUFNLEVBQUU7WUFFM0UsSUFBSUUsZUFBZUMsTUFBTWtDLFFBQVFoQyxLQUFLQyxLQUFLQyxZQUFZO2dCQUNyRE0sWUFBWVYsTUFBTWtDLFFBQVFoQyxLQUFLQyxLQUFLQztnQkFDcEMrQixTQUFTO1lBQ1g7WUFFQUM7UUFDRjtRQUVBLElBQUksQ0FBQ0QsUUFBUTtZQUNYRyxRQUFRQyxJQUFJLENBQUMsMEJBQWlDLE9BQVB0QztRQUN6QztJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUssSUFBSVEsSUFBSSxHQUFHQSxJQUFJRCxNQUFNQyxJQUFLO1FBQzdCLElBQUssSUFBSStCLElBQUksR0FBR0EsSUFBSWhDLE1BQU1nQyxJQUFLO1lBQzdCLElBQUl4QyxJQUFJLENBQUNTLEVBQUUsQ0FBQytCLEVBQUUsS0FBSyxJQUFJO2dCQUNyQnhDLElBQUksQ0FBQ1MsRUFBRSxDQUFDK0IsRUFBRSxHQUFHeEQsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssSUFBSStDLFFBQVE7WUFDdEQ7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMakM7UUFDQTBCO1FBQ0FDLFdBQVdMLG1CQUFtQkssWUFBWWM7SUFDNUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL251bWJlclNlYXJjaEdlbmVyYXRvci50cz82OTFjIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBOdW1iZXJTZWFyY2hPcHRpb25zIHtcbiAgc2l6ZT86IG51bWJlcjtcbiAgbWluTnVtYmVyPzogbnVtYmVyO1xuICBtYXhOdW1iZXI/OiBudW1iZXI7XG4gIG51bWJlcnNUb0ZpbmQ/OiBudW1iZXI7XG4gIGNvbXBsZXhpdHk6ICdlYXN5JyB8ICdtZWRpdW0nIHwgJ2hhcmQnO1xuICBpbmNsdWRlRXF1YXRpb25zPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEVxdWF0aW9uSW5mbyB7XG4gIGVxdWF0aW9uOiBzdHJpbmc7XG4gIHJlc3VsdDogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU51bWJlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcXVhdGlvbih0YXJnZXROdW1iZXI6IG51bWJlciwgY29tcGxleGl0eTogJ2Vhc3knIHwgJ21lZGl1bScgfCAnaGFyZCcpOiBFcXVhdGlvbkluZm8ge1xuICBzd2l0Y2ggKGNvbXBsZXhpdHkpIHtcbiAgICBjYXNlICdlYXN5JzpcbiAgICAgIC8vIFNpbXBsZSBhZGRpdGlvbiBvciBzdWJ0cmFjdGlvblxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUgJiYgdGFyZ2V0TnVtYmVyID4gMikge1xuICAgICAgICBjb25zdCBudW0xID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIoMSwgdGFyZ2V0TnVtYmVyIC0gMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXF1YXRpb246IGAke251bTF9ICsgJHt0YXJnZXROdW1iZXIgLSBudW0xfSA9ID9gLFxuICAgICAgICAgIHJlc3VsdDogdGFyZ2V0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBudW0xID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIodGFyZ2V0TnVtYmVyICsgMSwgdGFyZ2V0TnVtYmVyICsgMTApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVxdWF0aW9uOiBgJHtudW0xfSAtICR7bnVtMSAtIHRhcmdldE51bWJlcn0gPSA/YCxcbiAgICAgICAgICByZXN1bHQ6IHRhcmdldE51bWJlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIFxuICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAvLyBNdWx0aXBsaWNhdGlvbiBvciBkaXZpc2lvblxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIoMiwgNSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXF1YXRpb246IGAke3RhcmdldE51bWJlcn0gw5cgJHtmYWN0b3J9ID0gP2AsXG4gICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXIgKiBmYWN0b3JcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyKDIsIDUpO1xuICAgICAgICBjb25zdCBwcm9kdWN0ID0gdGFyZ2V0TnVtYmVyICogZmFjdG9yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVxdWF0aW9uOiBgJHtwcm9kdWN0fSDDtyAke2ZhY3Rvcn0gPSA/YCxcbiAgICAgICAgICByZXN1bHQ6IHRhcmdldE51bWJlclxuICAgICAgICB9O1xuICAgICAgfVxuICAgIFxuICAgIGNhc2UgJ2hhcmQnOlxuICAgICAgLy8gTWl4ZWQgb3BlcmF0aW9uc1xuICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IFsnKycsICctJywgJ8OXJ107XG4gICAgICBjb25zdCBvcCA9IG9wZXJhdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb3BlcmF0aW9ucy5sZW5ndGgpXTtcbiAgICAgIGNvbnN0IG51bTEgPSBnZW5lcmF0ZVJhbmRvbU51bWJlcigxLCAxMCk7XG4gICAgICBjb25zdCBudW0yID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIoMSwgMTApO1xuICAgICAgXG4gICAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcXVhdGlvbjogYCgke251bTF9IMOXICR7bnVtMn0pICsgJHt0YXJnZXROdW1iZXIgLSAobnVtMSAqIG51bTIpfSA9ID9gLFxuICAgICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXF1YXRpb246IGAoJHtudW0xfSDDlyAke251bTJ9KSAtICR7KG51bTEgKiBudW0yKSAtIHRhcmdldE51bWJlcn0gPSA/YCxcbiAgICAgICAgICAgIHJlc3VsdDogdGFyZ2V0TnVtYmVyXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnw5cnOlxuICAgICAgICAgIGlmICh0YXJnZXROdW1iZXIgJSBudW0xID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcXVhdGlvbjogYCR7dGFyZ2V0TnVtYmVyIC8gbnVtMX0gw5cgJHtudW0xfSA9YCxcbiAgICAgICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVxdWF0aW9uOiBgJHtudW0xfSDDlyAke251bTJ9ICsgJHt0YXJnZXROdW1iZXIgLSAobnVtMSAqIG51bTIpfSA9ID9gLFxuICAgICAgICAgICAgICByZXN1bHQ6IHRhcmdldE51bWJlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHNpbXBsZSBlcXVhdGlvblxuICByZXR1cm4ge1xuICAgIGVxdWF0aW9uOiBgPyA9ICR7dGFyZ2V0TnVtYmVyfWAsXG4gICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FuUGxhY2VOdW1iZXIoXG4gIGdyaWQ6IHN0cmluZ1tdW10sXG4gIG51bWJlcjogc3RyaW5nLFxuICByb3c6IG51bWJlcixcbiAgY29sOiBudW1iZXIsXG4gIGRpcmVjdGlvbjogW251bWJlciwgbnVtYmVyXVxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IG51bUxlbmd0aCA9IG51bWJlci5sZW5ndGg7XG4gIGNvbnN0IFtkUm93LCBkQ29sXSA9IGRpcmVjdGlvbjtcbiAgY29uc3Qgc2l6ZSA9IGdyaWQubGVuZ3RoO1xuXG4gIC8vIENoZWNrIGlmIHRoZSBudW1iZXIgZml0cyB3aXRoaW4gdGhlIGdyaWQgYm91bmRzXG4gIGlmIChcbiAgICByb3cgKyBkUm93ICogKG51bUxlbmd0aCAtIDEpID49IHNpemUgfHxcbiAgICByb3cgKyBkUm93ICogKG51bUxlbmd0aCAtIDEpIDwgMCB8fFxuICAgIGNvbCArIGRDb2wgKiAobnVtTGVuZ3RoIC0gMSkgPj0gc2l6ZSB8fFxuICAgIGNvbCArIGRDb2wgKiAobnVtTGVuZ3RoIC0gMSkgPCAwXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRoZSBjZWxscyBhcmUgZW1wdHlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1MZW5ndGg7IGkrKykge1xuICAgIGlmIChncmlkW3JvdyArIGRSb3cgKiBpXVtjb2wgKyBkQ29sICogaV0gIT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBsYWNlTnVtYmVyKFxuICBncmlkOiBzdHJpbmdbXVtdLFxuICBudW1iZXI6IHN0cmluZyxcbiAgcm93OiBudW1iZXIsXG4gIGNvbDogbnVtYmVyLFxuICBkaXJlY3Rpb246IFtudW1iZXIsIG51bWJlcl1cbik6IHZvaWQge1xuICBjb25zdCBbZFJvdywgZENvbF0gPSBkaXJlY3Rpb247XG4gIGNvbnN0IGRpZ2l0cyA9IG51bWJlci5zcGxpdCgnJyk7XG4gIGRpZ2l0cy5mb3JFYWNoKChkaWdpdCwgaSkgPT4ge1xuICAgIGdyaWRbcm93ICsgZFJvdyAqIGldW2NvbCArIGRDb2wgKiBpXSA9IGRpZ2l0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0aW9ucyhjb21wbGV4aXR5OiAnZWFzeScgfCAnbWVkaXVtJyB8ICdoYXJkJyk6IFtudW1iZXIsIG51bWJlcl1bXSB7XG4gIGNvbnN0IGRpcmVjdGlvbnM6IFtudW1iZXIsIG51bWJlcl1bXSA9IFtcbiAgICBbMCwgMV0sICAgLy8gcmlnaHRcbiAgICBbMSwgMF0sICAgLy8gZG93blxuICBdO1xuXG4gIGlmIChjb21wbGV4aXR5ID09PSAnbWVkaXVtJyB8fCBjb21wbGV4aXR5ID09PSAnaGFyZCcpIHtcbiAgICBkaXJlY3Rpb25zLnB1c2goXG4gICAgICBbMSwgMV0sICAvLyBkaWFnb25hbCBkb3duLXJpZ2h0XG4gICAgICBbLTEsIDFdICAvLyBkaWFnb25hbCB1cC1yaWdodFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gZGlyZWN0aW9ucztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTnVtYmVyU2VhcmNoKHtcbiAgc2l6ZSA9IDE1LFxuICBtaW5OdW1iZXIgPSAxLFxuICBtYXhOdW1iZXIgPSA5OTksXG4gIG51bWJlcnNUb0ZpbmQgPSA4LFxuICBjb21wbGV4aXR5ID0gJ21lZGl1bScsXG4gIGluY2x1ZGVFcXVhdGlvbnMgPSBmYWxzZVxufTogTnVtYmVyU2VhcmNoT3B0aW9ucykge1xuICAvLyBJbml0aWFsaXplIGVtcHR5IGdyaWRcbiAgY29uc3QgZ3JpZDogc3RyaW5nW11bXSA9IEFycmF5KHNpemUpXG4gICAgLmZpbGwobnVsbClcbiAgICAubWFwKCgpID0+IEFycmF5KHNpemUpLmZpbGwoJycpKTtcblxuICAvLyBHZW5lcmF0ZSByYW5kb20gbnVtYmVyc1xuICBjb25zdCBudW1iZXJzOiBudW1iZXJbXSA9IFtdO1xuICBjb25zdCBlcXVhdGlvbnM6IEVxdWF0aW9uSW5mb1tdID0gW107XG4gIFxuICB3aGlsZSAobnVtYmVycy5sZW5ndGggPCBudW1iZXJzVG9GaW5kKSB7XG4gICAgY29uc3QgbnVtID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIobWluTnVtYmVyLCBtYXhOdW1iZXIpO1xuICAgIGlmICghbnVtYmVycy5pbmNsdWRlcyhudW0pKSB7XG4gICAgICBudW1iZXJzLnB1c2gobnVtKTtcbiAgICAgIGlmIChpbmNsdWRlRXF1YXRpb25zKSB7XG4gICAgICAgIGVxdWF0aW9ucy5wdXNoKGdlbmVyYXRlRXF1YXRpb24obnVtLCBjb21wbGV4aXR5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU29ydCBudW1iZXJzIGZvciBjb25zaXN0ZW50IGRpZmZpY3VsdHlcbiAgbnVtYmVycy5zb3J0KChhLCBiKSA9PiBiLnRvU3RyaW5nKCkubGVuZ3RoIC0gYS50b1N0cmluZygpLmxlbmd0aCk7XG5cbiAgY29uc3QgZGlyZWN0aW9ucyA9IGdldERpcmVjdGlvbnMoY29tcGxleGl0eSk7XG5cbiAgLy8gUGxhY2UgbnVtYmVycyBpbiB0aGUgZ3JpZFxuICBudW1iZXJzLmZvckVhY2gobnVtYmVyID0+IHtcbiAgICBjb25zdCBudW1TdHIgPSBudW1iZXIudG9TdHJpbmcoKTtcbiAgICBsZXQgcGxhY2VkID0gZmFsc2U7XG4gICAgbGV0IGF0dGVtcHRzID0gMDtcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IHNpemUgKiBzaXplO1xuXG4gICAgd2hpbGUgKCFwbGFjZWQgJiYgYXR0ZW1wdHMgPCBtYXhBdHRlbXB0cykge1xuICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgICBjb25zdCBjb2wgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzaXplKTtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRpcmVjdGlvbnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGlyZWN0aW9ucy5sZW5ndGgpXTtcblxuICAgICAgaWYgKGNhblBsYWNlTnVtYmVyKGdyaWQsIG51bVN0ciwgcm93LCBjb2wsIGRpcmVjdGlvbikpIHtcbiAgICAgICAgcGxhY2VOdW1iZXIoZ3JpZCwgbnVtU3RyLCByb3csIGNvbCwgZGlyZWN0aW9uKTtcbiAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgYXR0ZW1wdHMrKztcbiAgICB9XG5cbiAgICBpZiAoIXBsYWNlZCkge1xuICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgcGxhY2UgbnVtYmVyICR7bnVtYmVyfWApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRmlsbCBlbXB0eSBjZWxscyB3aXRoIHJhbmRvbSBkaWdpdHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgICAgaWYgKGdyaWRbaV1bal0gPT09ICcnKSB7XG4gICAgICAgIGdyaWRbaV1bal0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCkudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdyaWQsXG4gICAgbnVtYmVycyxcbiAgICBlcXVhdGlvbnM6IGluY2x1ZGVFcXVhdGlvbnMgPyBlcXVhdGlvbnMgOiB1bmRlZmluZWRcbiAgfTtcbn0iXSwibmFtZXMiOlsiZ2VuZXJhdGVSYW5kb21OdW1iZXIiLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJnZW5lcmF0ZUVxdWF0aW9uIiwidGFyZ2V0TnVtYmVyIiwiY29tcGxleGl0eSIsIm51bTEiLCJlcXVhdGlvbiIsInJlc3VsdCIsImZhY3RvciIsInByb2R1Y3QiLCJvcGVyYXRpb25zIiwib3AiLCJsZW5ndGgiLCJudW0yIiwiY2FuUGxhY2VOdW1iZXIiLCJncmlkIiwibnVtYmVyIiwicm93IiwiY29sIiwiZGlyZWN0aW9uIiwibnVtTGVuZ3RoIiwiZFJvdyIsImRDb2wiLCJzaXplIiwiaSIsInBsYWNlTnVtYmVyIiwiZGlnaXRzIiwic3BsaXQiLCJmb3JFYWNoIiwiZGlnaXQiLCJnZXREaXJlY3Rpb25zIiwiZGlyZWN0aW9ucyIsInB1c2giLCJnZW5lcmF0ZU51bWJlclNlYXJjaCIsIm1pbk51bWJlciIsIm1heE51bWJlciIsIm51bWJlcnNUb0ZpbmQiLCJpbmNsdWRlRXF1YXRpb25zIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwibnVtYmVycyIsImVxdWF0aW9ucyIsIm51bSIsImluY2x1ZGVzIiwic29ydCIsImEiLCJiIiwidG9TdHJpbmciLCJudW1TdHIiLCJwbGFjZWQiLCJhdHRlbXB0cyIsIm1heEF0dGVtcHRzIiwiY29uc29sZSIsIndhcm4iLCJqIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/numberSearchGenerator.ts\n"));

/***/ })

});