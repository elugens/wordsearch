"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/numbersearch/page",{

/***/ "(app-pages-browser)/./src/lib/numberSearchGenerator.ts":
/*!******************************************!*\
  !*** ./src/lib/numberSearchGenerator.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateNumberSearch: function() { return /* binding */ generateNumberSearch; }\n/* harmony export */ });\nfunction generateRandomNumber(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\nfunction generateEquation(targetNumber, complexity) {\n    switch(complexity){\n        case \"easy\":\n            // Simple addition or subtraction\n            if (Math.random() > 0.5 && targetNumber > 2) {\n                const num1 = generateRandomNumber(1, targetNumber - 1);\n                return {\n                    equation: \"\".concat(num1, \" + \").concat(targetNumber - num1, \" =\"),\n                    result: targetNumber\n                };\n            } else {\n                const num1 = generateRandomNumber(targetNumber + 1, targetNumber + 10);\n                return {\n                    equation: \"\".concat(num1, \" - \").concat(num1 - targetNumber, \" =\"),\n                    result: targetNumber\n                };\n            }\n        case \"medium\":\n            // Multiplication or division\n            if (Math.random() > 0.5) {\n                const factor = generateRandomNumber(2, 5);\n                return {\n                    equation: \"\".concat(targetNumber, \" \\xd7 \").concat(factor, \" =\"),\n                    result: targetNumber * factor\n                };\n            } else {\n                const factor = generateRandomNumber(2, 5);\n                const product = targetNumber * factor;\n                return {\n                    equation: \"\".concat(product, \" \\xf7 \").concat(factor, \" =\"),\n                    result: targetNumber\n                };\n            }\n        case \"hard\":\n            // Mixed operations\n            const operations = [\n                \"+\",\n                \"-\",\n                \"\\xd7\"\n            ];\n            const op = operations[Math.floor(Math.random() * operations.length)];\n            const num1 = generateRandomNumber(1, 10);\n            const num2 = generateRandomNumber(1, 10);\n            switch(op){\n                case \"+\":\n                    return {\n                        equation: \"(\".concat(num1, \" \\xd7 \").concat(num2, \") + \").concat(targetNumber - num1 * num2, \" =\"),\n                        result: targetNumber\n                    };\n                case \"-\":\n                    return {\n                        equation: \"(\".concat(num1, \" \\xd7 \").concat(num2, \") - \").concat(num1 * num2 - targetNumber, \" =\"),\n                        result: targetNumber\n                    };\n                case \"\\xd7\":\n                    if (targetNumber % num1 === 0) {\n                        return {\n                            equation: \"\".concat(targetNumber / num1, \" \\xd7 \").concat(num1, \" =\"),\n                            result: targetNumber\n                        };\n                    } else {\n                        return {\n                            equation: \"\".concat(num1, \" \\xd7 \").concat(num2, \" + \").concat(targetNumber - num1 * num2, \" =\"),\n                            result: targetNumber\n                        };\n                    }\n            }\n    }\n    // Fallback simple equation\n    return {\n        equation: \"? = \".concat(targetNumber),\n        result: targetNumber\n    };\n}\nfunction canPlaceNumber(grid, number, row, col, direction) {\n    const numLength = number.length;\n    const [dRow, dCol] = direction;\n    const size = grid.length;\n    // Check if the number fits within the grid bounds\n    if (row + dRow * (numLength - 1) >= size || row + dRow * (numLength - 1) < 0 || col + dCol * (numLength - 1) >= size || col + dCol * (numLength - 1) < 0) {\n        return false;\n    }\n    // Check if the cells are empty\n    for(let i = 0; i < numLength; i++){\n        if (grid[row + dRow * i][col + dCol * i] !== \"\") {\n            return false;\n        }\n    }\n    return true;\n}\nfunction placeNumber(grid, number, row, col, direction) {\n    const [dRow, dCol] = direction;\n    const digits = number.split(\"\");\n    digits.forEach((digit, i)=>{\n        grid[row + dRow * i][col + dCol * i] = digit;\n    });\n}\nfunction getDirections(complexity) {\n    const directions = [\n        [\n            0,\n            1\n        ],\n        [\n            1,\n            0\n        ]\n    ];\n    if (complexity === \"medium\" || complexity === \"hard\") {\n        directions.push([\n            1,\n            1\n        ], [\n            -1,\n            1\n        ] // diagonal up-right\n        );\n    }\n    return directions;\n}\nfunction generateNumberSearch(param) {\n    let { size = 15, minNumber = 1, maxNumber = 999, numbersToFind = 8, complexity = \"medium\", includeEquations = false } = param;\n    // Initialize empty grid\n    const grid = Array(size).fill(null).map(()=>Array(size).fill(\"\"));\n    // Generate random numbers\n    const numbers = [];\n    const equations = [];\n    while(numbers.length < numbersToFind){\n        const num = generateRandomNumber(minNumber, maxNumber);\n        if (!numbers.includes(num)) {\n            numbers.push(num);\n            if (includeEquations) {\n                equations.push(generateEquation(num, complexity));\n            }\n        }\n    }\n    // Sort numbers for consistent difficulty\n    numbers.sort((a, b)=>b.toString().length - a.toString().length);\n    const directions = getDirections(complexity);\n    // Place numbers in the grid\n    numbers.forEach((number)=>{\n        const numStr = number.toString();\n        let placed = false;\n        let attempts = 0;\n        const maxAttempts = size * size;\n        while(!placed && attempts < maxAttempts){\n            const row = Math.floor(Math.random() * size);\n            const col = Math.floor(Math.random() * size);\n            const direction = directions[Math.floor(Math.random() * directions.length)];\n            if (canPlaceNumber(grid, numStr, row, col, direction)) {\n                placeNumber(grid, numStr, row, col, direction);\n                placed = true;\n            }\n            attempts++;\n        }\n        if (!placed) {\n            console.warn(\"Could not place number \".concat(number));\n        }\n    });\n    // Fill empty cells with random digits\n    for(let i = 0; i < size; i++){\n        for(let j = 0; j < size; j++){\n            if (grid[i][j] === \"\") {\n                grid[i][j] = Math.floor(Math.random() * 10).toString();\n            }\n        }\n    }\n    return {\n        grid,\n        numbers,\n        equations: includeEquations ? equations : undefined\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvbnVtYmVyU2VhcmNoR2VuZXJhdG9yLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFjQSxTQUFTQSxxQkFBcUJDLEdBQVcsRUFBRUMsR0FBVztJQUNwRCxPQUFPQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBTUgsQ0FBQUEsTUFBTUQsTUFBTSxNQUFNQTtBQUN2RDtBQUVBLFNBQVNLLGlCQUFpQkMsWUFBb0IsRUFBRUMsVUFBc0M7SUFDcEYsT0FBUUE7UUFDTixLQUFLO1lBQ0gsaUNBQWlDO1lBQ2pDLElBQUlMLEtBQUtFLE1BQU0sS0FBSyxPQUFPRSxlQUFlLEdBQUc7Z0JBQzNDLE1BQU1FLE9BQU9ULHFCQUFxQixHQUFHTyxlQUFlO2dCQUNwRCxPQUFPO29CQUNMRyxVQUFVLEdBQWFILE9BQVZFLE1BQUssT0FBeUIsT0FBcEJGLGVBQWVFLE1BQUs7b0JBQzNDRSxRQUFRSjtnQkFDVjtZQUNGLE9BQU87Z0JBQ0wsTUFBTUUsT0FBT1QscUJBQXFCTyxlQUFlLEdBQUdBLGVBQWU7Z0JBQ25FLE9BQU87b0JBQ0xHLFVBQVUsR0FBYUQsT0FBVkEsTUFBSyxPQUF5QixPQUFwQkEsT0FBT0YsY0FBYTtvQkFDM0NJLFFBQVFKO2dCQUNWO1lBQ0Y7UUFFRixLQUFLO1lBQ0gsNkJBQTZCO1lBQzdCLElBQUlKLEtBQUtFLE1BQU0sS0FBSyxLQUFLO2dCQUN2QixNQUFNTyxTQUFTWixxQkFBcUIsR0FBRztnQkFDdkMsT0FBTztvQkFDTFUsVUFBVSxHQUFxQkUsT0FBbEJMLGNBQWEsVUFBWSxPQUFQSyxRQUFPO29CQUN0Q0QsUUFBUUosZUFBZUs7Z0JBQ3pCO1lBQ0YsT0FBTztnQkFDTCxNQUFNQSxTQUFTWixxQkFBcUIsR0FBRztnQkFDdkMsTUFBTWEsVUFBVU4sZUFBZUs7Z0JBQy9CLE9BQU87b0JBQ0xGLFVBQVUsR0FBZ0JFLE9BQWJDLFNBQVEsVUFBWSxPQUFQRCxRQUFPO29CQUNqQ0QsUUFBUUo7Z0JBQ1Y7WUFD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QUFVLENBQUNoQyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLE1BQU0sS0FBSzhCLFdBQVduQixNQUFNLEVBQUU7WUFFM0UsSUFBSUUsZUFBZUMsTUFBTWtDLFFBQVFoQyxLQUFLQyxLQUFLQyxZQUFZO2dCQUNyRE0sWUFBWVYsTUFBTWtDLFFBQVFoQyxLQUFLQyxLQUFLQztnQkFDcEMrQixTQUFTO1lBQ1g7WUFFQUM7UUFDRjtRQUVBLElBQUksQ0FBQ0QsUUFBUTtZQUNYRyxRQUFRQyxJQUFJLENBQUMsMEJBQWlDLE9BQVB0QztRQUN6QztJQUNGO0lBRUEsc0NBQXNDO0lBQ3RDLElBQUssSUFBSVEsSUFBSSxHQUFHQSxJQUFJRCxNQUFNQyxJQUFLO1FBQzdCLElBQUssSUFBSStCLElBQUksR0FBR0EsSUFBSWhDLE1BQU1nQyxJQUFLO1lBQzdCLElBQUl4QyxJQUFJLENBQUNTLEVBQUUsQ0FBQytCLEVBQUUsS0FBSyxJQUFJO2dCQUNyQnhDLElBQUksQ0FBQ1MsRUFBRSxDQUFDK0IsRUFBRSxHQUFHeEQsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssSUFBSStDLFFBQVE7WUFDdEQ7UUFDRjtJQUNGO0lBRUEsT0FBTztRQUNMakM7UUFDQTBCO1FBQ0FDLFdBQVdMLG1CQUFtQkssWUFBWWM7SUFDNUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL251bWJlclNlYXJjaEdlbmVyYXRvci50cz82OTFjIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBOdW1iZXJTZWFyY2hPcHRpb25zIHtcbiAgc2l6ZT86IG51bWJlcjtcbiAgbWluTnVtYmVyPzogbnVtYmVyO1xuICBtYXhOdW1iZXI/OiBudW1iZXI7XG4gIG51bWJlcnNUb0ZpbmQ/OiBudW1iZXI7XG4gIGNvbXBsZXhpdHk6ICdlYXN5JyB8ICdtZWRpdW0nIHwgJ2hhcmQnO1xuICBpbmNsdWRlRXF1YXRpb25zPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEVxdWF0aW9uSW5mbyB7XG4gIGVxdWF0aW9uOiBzdHJpbmc7XG4gIHJlc3VsdDogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU51bWJlcihtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pbjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVFcXVhdGlvbih0YXJnZXROdW1iZXI6IG51bWJlciwgY29tcGxleGl0eTogJ2Vhc3knIHwgJ21lZGl1bScgfCAnaGFyZCcpOiBFcXVhdGlvbkluZm8ge1xuICBzd2l0Y2ggKGNvbXBsZXhpdHkpIHtcbiAgICBjYXNlICdlYXN5JzpcbiAgICAgIC8vIFNpbXBsZSBhZGRpdGlvbiBvciBzdWJ0cmFjdGlvblxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUgJiYgdGFyZ2V0TnVtYmVyID4gMikge1xuICAgICAgICBjb25zdCBudW0xID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIoMSwgdGFyZ2V0TnVtYmVyIC0gMSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXF1YXRpb246IGAke251bTF9ICsgJHt0YXJnZXROdW1iZXIgLSBudW0xfSA9YCxcbiAgICAgICAgICByZXN1bHQ6IHRhcmdldE51bWJlclxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbnVtMSA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyKHRhcmdldE51bWJlciArIDEsIHRhcmdldE51bWJlciArIDEwKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcXVhdGlvbjogYCR7bnVtMX0gLSAke251bTEgLSB0YXJnZXROdW1iZXJ9ID1gLFxuICAgICAgICAgIHJlc3VsdDogdGFyZ2V0TnVtYmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgXG4gICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgIC8vIE11bHRpcGxpY2F0aW9uIG9yIGRpdmlzaW9uXG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICBjb25zdCBmYWN0b3IgPSBnZW5lcmF0ZVJhbmRvbU51bWJlcigyLCA1KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlcXVhdGlvbjogYCR7dGFyZ2V0TnVtYmVyfSDDlyAke2ZhY3Rvcn0gPWAsXG4gICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXIgKiBmYWN0b3JcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyKDIsIDUpO1xuICAgICAgICBjb25zdCBwcm9kdWN0ID0gdGFyZ2V0TnVtYmVyICogZmFjdG9yO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGVxdWF0aW9uOiBgJHtwcm9kdWN0fSDDtyAke2ZhY3Rvcn0gPWAsXG4gICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBcbiAgICBjYXNlICdoYXJkJzpcbiAgICAgIC8vIE1peGVkIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbJysnLCAnLScsICfDlyddO1xuICAgICAgY29uc3Qgb3AgPSBvcGVyYXRpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG9wZXJhdGlvbnMubGVuZ3RoKV07XG4gICAgICBjb25zdCBudW0xID0gZ2VuZXJhdGVSYW5kb21OdW1iZXIoMSwgMTApO1xuICAgICAgY29uc3QgbnVtMiA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyKDEsIDEwKTtcbiAgICAgIFxuICAgICAgc3dpdGNoIChvcCkge1xuICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXF1YXRpb246IGAoJHtudW0xfSDDlyAke251bTJ9KSArICR7dGFyZ2V0TnVtYmVyIC0gKG51bTEgKiBudW0yKX0gPWAsXG4gICAgICAgICAgICByZXN1bHQ6IHRhcmdldE51bWJlclxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcXVhdGlvbjogYCgke251bTF9IMOXICR7bnVtMn0pIC0gJHsobnVtMSAqIG51bTIpIC0gdGFyZ2V0TnVtYmVyfSA9YCxcbiAgICAgICAgICAgIHJlc3VsdDogdGFyZ2V0TnVtYmVyXG4gICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnw5cnOlxuICAgICAgICAgIGlmICh0YXJnZXROdW1iZXIgJSBudW0xID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlcXVhdGlvbjogYCR7dGFyZ2V0TnVtYmVyIC8gbnVtMX0gw5cgJHtudW0xfSA9YCxcbiAgICAgICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGVxdWF0aW9uOiBgJHtudW0xfSDDlyAke251bTJ9ICsgJHt0YXJnZXROdW1iZXIgLSAobnVtMSAqIG51bTIpfSA9YCxcbiAgICAgICAgICAgICAgcmVzdWx0OiB0YXJnZXROdW1iZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIFxuICAvLyBGYWxsYmFjayBzaW1wbGUgZXF1YXRpb25cbiAgcmV0dXJuIHtcbiAgICBlcXVhdGlvbjogYD8gPSAke3RhcmdldE51bWJlcn1gLFxuICAgIHJlc3VsdDogdGFyZ2V0TnVtYmVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhblBsYWNlTnVtYmVyKFxuICBncmlkOiBzdHJpbmdbXVtdLFxuICBudW1iZXI6IHN0cmluZyxcbiAgcm93OiBudW1iZXIsXG4gIGNvbDogbnVtYmVyLFxuICBkaXJlY3Rpb246IFtudW1iZXIsIG51bWJlcl1cbik6IGJvb2xlYW4ge1xuICBjb25zdCBudW1MZW5ndGggPSBudW1iZXIubGVuZ3RoO1xuICBjb25zdCBbZFJvdywgZENvbF0gPSBkaXJlY3Rpb247XG4gIGNvbnN0IHNpemUgPSBncmlkLmxlbmd0aDtcblxuICAvLyBDaGVjayBpZiB0aGUgbnVtYmVyIGZpdHMgd2l0aGluIHRoZSBncmlkIGJvdW5kc1xuICBpZiAoXG4gICAgcm93ICsgZFJvdyAqIChudW1MZW5ndGggLSAxKSA+PSBzaXplIHx8XG4gICAgcm93ICsgZFJvdyAqIChudW1MZW5ndGggLSAxKSA8IDAgfHxcbiAgICBjb2wgKyBkQ29sICogKG51bUxlbmd0aCAtIDEpID49IHNpemUgfHxcbiAgICBjb2wgKyBkQ29sICogKG51bUxlbmd0aCAtIDEpIDwgMFxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aGUgY2VsbHMgYXJlIGVtcHR5XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZ3JpZFtyb3cgKyBkUm93ICogaV1bY29sICsgZENvbCAqIGldICE9PSAnJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBwbGFjZU51bWJlcihcbiAgZ3JpZDogc3RyaW5nW11bXSxcbiAgbnVtYmVyOiBzdHJpbmcsXG4gIHJvdzogbnVtYmVyLFxuICBjb2w6IG51bWJlcixcbiAgZGlyZWN0aW9uOiBbbnVtYmVyLCBudW1iZXJdXG4pOiB2b2lkIHtcbiAgY29uc3QgW2RSb3csIGRDb2xdID0gZGlyZWN0aW9uO1xuICBjb25zdCBkaWdpdHMgPSBudW1iZXIuc3BsaXQoJycpO1xuICBkaWdpdHMuZm9yRWFjaCgoZGlnaXQsIGkpID0+IHtcbiAgICBncmlkW3JvdyArIGRSb3cgKiBpXVtjb2wgKyBkQ29sICogaV0gPSBkaWdpdDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldERpcmVjdGlvbnMoY29tcGxleGl0eTogJ2Vhc3knIHwgJ21lZGl1bScgfCAnaGFyZCcpOiBbbnVtYmVyLCBudW1iZXJdW10ge1xuICBjb25zdCBkaXJlY3Rpb25zOiBbbnVtYmVyLCBudW1iZXJdW10gPSBbXG4gICAgWzAsIDFdLCAgIC8vIHJpZ2h0XG4gICAgWzEsIDBdLCAgIC8vIGRvd25cbiAgXTtcblxuICBpZiAoY29tcGxleGl0eSA9PT0gJ21lZGl1bScgfHwgY29tcGxleGl0eSA9PT0gJ2hhcmQnKSB7XG4gICAgZGlyZWN0aW9ucy5wdXNoKFxuICAgICAgWzEsIDFdLCAgLy8gZGlhZ29uYWwgZG93bi1yaWdodFxuICAgICAgWy0xLCAxXSAgLy8gZGlhZ29uYWwgdXAtcmlnaHRcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGRpcmVjdGlvbnM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU51bWJlclNlYXJjaCh7XG4gIHNpemUgPSAxNSxcbiAgbWluTnVtYmVyID0gMSxcbiAgbWF4TnVtYmVyID0gOTk5LFxuICBudW1iZXJzVG9GaW5kID0gOCxcbiAgY29tcGxleGl0eSA9ICdtZWRpdW0nLFxuICBpbmNsdWRlRXF1YXRpb25zID0gZmFsc2Vcbn06IE51bWJlclNlYXJjaE9wdGlvbnMpIHtcbiAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBncmlkXG4gIGNvbnN0IGdyaWQ6IHN0cmluZ1tdW10gPSBBcnJheShzaXplKVxuICAgIC5maWxsKG51bGwpXG4gICAgLm1hcCgoKSA9PiBBcnJheShzaXplKS5maWxsKCcnKSk7XG5cbiAgLy8gR2VuZXJhdGUgcmFuZG9tIG51bWJlcnNcbiAgY29uc3QgbnVtYmVyczogbnVtYmVyW10gPSBbXTtcbiAgY29uc3QgZXF1YXRpb25zOiBFcXVhdGlvbkluZm9bXSA9IFtdO1xuICBcbiAgd2hpbGUgKG51bWJlcnMubGVuZ3RoIDwgbnVtYmVyc1RvRmluZCkge1xuICAgIGNvbnN0IG51bSA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyKG1pbk51bWJlciwgbWF4TnVtYmVyKTtcbiAgICBpZiAoIW51bWJlcnMuaW5jbHVkZXMobnVtKSkge1xuICAgICAgbnVtYmVycy5wdXNoKG51bSk7XG4gICAgICBpZiAoaW5jbHVkZUVxdWF0aW9ucykge1xuICAgICAgICBlcXVhdGlvbnMucHVzaChnZW5lcmF0ZUVxdWF0aW9uKG51bSwgY29tcGxleGl0eSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNvcnQgbnVtYmVycyBmb3IgY29uc2lzdGVudCBkaWZmaWN1bHR5XG4gIG51bWJlcnMuc29ydCgoYSwgYikgPT4gYi50b1N0cmluZygpLmxlbmd0aCAtIGEudG9TdHJpbmcoKS5sZW5ndGgpO1xuXG4gIGNvbnN0IGRpcmVjdGlvbnMgPSBnZXREaXJlY3Rpb25zKGNvbXBsZXhpdHkpO1xuXG4gIC8vIFBsYWNlIG51bWJlcnMgaW4gdGhlIGdyaWRcbiAgbnVtYmVycy5mb3JFYWNoKG51bWJlciA9PiB7XG4gICAgY29uc3QgbnVtU3RyID0gbnVtYmVyLnRvU3RyaW5nKCk7XG4gICAgbGV0IHBsYWNlZCA9IGZhbHNlO1xuICAgIGxldCBhdHRlbXB0cyA9IDA7XG4gICAgY29uc3QgbWF4QXR0ZW1wdHMgPSBzaXplICogc2l6ZTtcblxuICAgIHdoaWxlICghcGxhY2VkICYmIGF0dGVtcHRzIDwgbWF4QXR0ZW1wdHMpIHtcbiAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHNpemUpO1xuICAgICAgY29uc3QgY29sID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogc2l6ZSk7XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBkaXJlY3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRpcmVjdGlvbnMubGVuZ3RoKV07XG5cbiAgICAgIGlmIChjYW5QbGFjZU51bWJlcihncmlkLCBudW1TdHIsIHJvdywgY29sLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgIHBsYWNlTnVtYmVyKGdyaWQsIG51bVN0ciwgcm93LCBjb2wsIGRpcmVjdGlvbik7XG4gICAgICAgIHBsYWNlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGF0dGVtcHRzKys7XG4gICAgfVxuXG4gICAgaWYgKCFwbGFjZWQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IHBsYWNlIG51bWJlciAke251bWJlcn1gKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEZpbGwgZW1wdHkgY2VsbHMgd2l0aCByYW5kb20gZGlnaXRzXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcbiAgICAgIGlmIChncmlkW2ldW2pdID09PSAnJykge1xuICAgICAgICBncmlkW2ldW2pdID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBncmlkLFxuICAgIG51bWJlcnMsXG4gICAgZXF1YXRpb25zOiBpbmNsdWRlRXF1YXRpb25zID8gZXF1YXRpb25zIDogdW5kZWZpbmVkXG4gIH07XG59Il0sIm5hbWVzIjpbImdlbmVyYXRlUmFuZG9tTnVtYmVyIiwibWluIiwibWF4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZ2VuZXJhdGVFcXVhdGlvbiIsInRhcmdldE51bWJlciIsImNvbXBsZXhpdHkiLCJudW0xIiwiZXF1YXRpb24iLCJyZXN1bHQiLCJmYWN0b3IiLCJwcm9kdWN0Iiwib3BlcmF0aW9ucyIsIm9wIiwibGVuZ3RoIiwibnVtMiIsImNhblBsYWNlTnVtYmVyIiwiZ3JpZCIsIm51bWJlciIsInJvdyIsImNvbCIsImRpcmVjdGlvbiIsIm51bUxlbmd0aCIsImRSb3ciLCJkQ29sIiwic2l6ZSIsImkiLCJwbGFjZU51bWJlciIsImRpZ2l0cyIsInNwbGl0IiwiZm9yRWFjaCIsImRpZ2l0IiwiZ2V0RGlyZWN0aW9ucyIsImRpcmVjdGlvbnMiLCJwdXNoIiwiZ2VuZXJhdGVOdW1iZXJTZWFyY2giLCJtaW5OdW1iZXIiLCJtYXhOdW1iZXIiLCJudW1iZXJzVG9GaW5kIiwiaW5jbHVkZUVxdWF0aW9ucyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsIm51bWJlcnMiLCJlcXVhdGlvbnMiLCJudW0iLCJpbmNsdWRlcyIsInNvcnQiLCJhIiwiYiIsInRvU3RyaW5nIiwibnVtU3RyIiwicGxhY2VkIiwiYXR0ZW1wdHMiLCJtYXhBdHRlbXB0cyIsImNvbnNvbGUiLCJ3YXJuIiwiaiIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/numberSearchGenerator.ts\n"));

/***/ })

});