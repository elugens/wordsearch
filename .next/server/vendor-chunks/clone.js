/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/clone";
exports.ids = ["vendor-chunks/clone"];
exports.modules = {

/***/ "(ssr)/./node_modules/clone/clone.js":
/*!*************************************!*\
  !*** ./node_modules/clone/clone.js ***!
  \*************************************/
/***/ ((module) => {

eval("var clone = function() {\n    \"use strict\";\n    function _instanceof(obj, type) {\n        return type != null && obj instanceof type;\n    }\n    var nativeMap;\n    try {\n        nativeMap = Map;\n    } catch (_) {\n        // maybe a reference error because no `Map`. Give it a dummy value that no\n        // value will ever be an instanceof.\n        nativeMap = function() {};\n    }\n    var nativeSet;\n    try {\n        nativeSet = Set;\n    } catch (_) {\n        nativeSet = function() {};\n    }\n    var nativePromise;\n    try {\n        nativePromise = Promise;\n    } catch (_) {\n        nativePromise = function() {};\n    }\n    /**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/ function clone(parent, circular, depth, prototype, includeNonEnumerable) {\n        if (typeof circular === \"object\") {\n            depth = circular.depth;\n            prototype = circular.prototype;\n            includeNonEnumerable = circular.includeNonEnumerable;\n            circular = circular.circular;\n        }\n        // maintain two arrays for circular references, where corresponding parents\n        // and children have the same index\n        var allParents = [];\n        var allChildren = [];\n        var useBuffer = typeof Buffer != \"undefined\";\n        if (typeof circular == \"undefined\") circular = true;\n        if (typeof depth == \"undefined\") depth = Infinity;\n        // recurse this function so we don't reset allParents and allChildren\n        function _clone(parent, depth) {\n            // cloning null always returns null\n            if (parent === null) return null;\n            if (depth === 0) return parent;\n            var child;\n            var proto;\n            if (typeof parent != \"object\") {\n                return parent;\n            }\n            if (_instanceof(parent, nativeMap)) {\n                child = new nativeMap();\n            } else if (_instanceof(parent, nativeSet)) {\n                child = new nativeSet();\n            } else if (_instanceof(parent, nativePromise)) {\n                child = new nativePromise(function(resolve, reject) {\n                    parent.then(function(value) {\n                        resolve(_clone(value, depth - 1));\n                    }, function(err) {\n                        reject(_clone(err, depth - 1));\n                    });\n                });\n            } else if (clone.__isArray(parent)) {\n                child = [];\n            } else if (clone.__isRegExp(parent)) {\n                child = new RegExp(parent.source, __getRegExpFlags(parent));\n                if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n            } else if (clone.__isDate(parent)) {\n                child = new Date(parent.getTime());\n            } else if (useBuffer && Buffer.isBuffer(parent)) {\n                if (Buffer.allocUnsafe) {\n                    // Node.js >= 4.5.0\n                    child = Buffer.allocUnsafe(parent.length);\n                } else {\n                    // Older Node.js versions\n                    child = new Buffer(parent.length);\n                }\n                parent.copy(child);\n                return child;\n            } else if (_instanceof(parent, Error)) {\n                child = Object.create(parent);\n            } else {\n                if (typeof prototype == \"undefined\") {\n                    proto = Object.getPrototypeOf(parent);\n                    child = Object.create(proto);\n                } else {\n                    child = Object.create(prototype);\n                    proto = prototype;\n                }\n            }\n            if (circular) {\n                var index = allParents.indexOf(parent);\n                if (index != -1) {\n                    return allChildren[index];\n                }\n                allParents.push(parent);\n                allChildren.push(child);\n            }\n            if (_instanceof(parent, nativeMap)) {\n                parent.forEach(function(value, key) {\n                    var keyChild = _clone(key, depth - 1);\n                    var valueChild = _clone(value, depth - 1);\n                    child.set(keyChild, valueChild);\n                });\n            }\n            if (_instanceof(parent, nativeSet)) {\n                parent.forEach(function(value) {\n                    var entryChild = _clone(value, depth - 1);\n                    child.add(entryChild);\n                });\n            }\n            for(var i in parent){\n                var attrs;\n                if (proto) {\n                    attrs = Object.getOwnPropertyDescriptor(proto, i);\n                }\n                if (attrs && attrs.set == null) {\n                    continue;\n                }\n                child[i] = _clone(parent[i], depth - 1);\n            }\n            if (Object.getOwnPropertySymbols) {\n                var symbols = Object.getOwnPropertySymbols(parent);\n                for(var i = 0; i < symbols.length; i++){\n                    // Don't need to worry about cloning a symbol because it is a primitive,\n                    // like a number or string.\n                    var symbol = symbols[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n                    if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n                        continue;\n                    }\n                    child[symbol] = _clone(parent[symbol], depth - 1);\n                    if (!descriptor.enumerable) {\n                        Object.defineProperty(child, symbol, {\n                            enumerable: false\n                        });\n                    }\n                }\n            }\n            if (includeNonEnumerable) {\n                var allPropertyNames = Object.getOwnPropertyNames(parent);\n                for(var i = 0; i < allPropertyNames.length; i++){\n                    var propertyName = allPropertyNames[i];\n                    var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n                    if (descriptor && descriptor.enumerable) {\n                        continue;\n                    }\n                    child[propertyName] = _clone(parent[propertyName], depth - 1);\n                    Object.defineProperty(child, propertyName, {\n                        enumerable: false\n                    });\n                }\n            }\n            return child;\n        }\n        return _clone(parent, depth);\n    }\n    /**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */ clone.clonePrototype = function clonePrototype(parent) {\n        if (parent === null) return null;\n        var c = function() {};\n        c.prototype = parent;\n        return new c();\n    };\n    // private utility functions\n    function __objToStr(o) {\n        return Object.prototype.toString.call(o);\n    }\n    clone.__objToStr = __objToStr;\n    function __isDate(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Date]\";\n    }\n    clone.__isDate = __isDate;\n    function __isArray(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object Array]\";\n    }\n    clone.__isArray = __isArray;\n    function __isRegExp(o) {\n        return typeof o === \"object\" && __objToStr(o) === \"[object RegExp]\";\n    }\n    clone.__isRegExp = __isRegExp;\n    function __getRegExpFlags(re) {\n        var flags = \"\";\n        if (re.global) flags += \"g\";\n        if (re.ignoreCase) flags += \"i\";\n        if (re.multiline) flags += \"m\";\n        return flags;\n    }\n    clone.__getRegExpFlags = __getRegExpFlags;\n    return clone;\n}();\nif ( true && module.exports) {\n    module.exports = clone;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBZ0IsR0FBR0E7SUFFekIsT0FBT2pDO0FBQ1A7QUFFQSxJQUFJLEtBQWtCLElBQVkrRSxPQUFPQyxPQUFPLEVBQUU7SUFDaERELE9BQU9DLE9BQU8sR0FBR2hGO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd29yZHNlYXJjaC8uL25vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcz8xZGM5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAvLyBOb2RlLmpzID49IDQuNS4wXG4gICAgICAgIGNoaWxkID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT2xkZXIgTm9kZS5qcyB2ZXJzaW9uc1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIl0sIm5hbWVzIjpbImNsb25lIiwiX2luc3RhbmNlb2YiLCJvYmoiLCJ0eXBlIiwibmF0aXZlTWFwIiwiTWFwIiwiXyIsIm5hdGl2ZVNldCIsIlNldCIsIm5hdGl2ZVByb21pc2UiLCJQcm9taXNlIiwicGFyZW50IiwiY2lyY3VsYXIiLCJkZXB0aCIsInByb3RvdHlwZSIsImluY2x1ZGVOb25FbnVtZXJhYmxlIiwiYWxsUGFyZW50cyIsImFsbENoaWxkcmVuIiwidXNlQnVmZmVyIiwiQnVmZmVyIiwiSW5maW5pdHkiLCJfY2xvbmUiLCJjaGlsZCIsInByb3RvIiwicmVzb2x2ZSIsInJlamVjdCIsInRoZW4iLCJ2YWx1ZSIsImVyciIsIl9faXNBcnJheSIsIl9faXNSZWdFeHAiLCJSZWdFeHAiLCJzb3VyY2UiLCJfX2dldFJlZ0V4cEZsYWdzIiwibGFzdEluZGV4IiwiX19pc0RhdGUiLCJEYXRlIiwiZ2V0VGltZSIsImlzQnVmZmVyIiwiYWxsb2NVbnNhZmUiLCJsZW5ndGgiLCJjb3B5IiwiRXJyb3IiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsImluZGV4IiwiaW5kZXhPZiIsInB1c2giLCJmb3JFYWNoIiwia2V5Iiwia2V5Q2hpbGQiLCJ2YWx1ZUNoaWxkIiwic2V0IiwiZW50cnlDaGlsZCIsImFkZCIsImkiLCJhdHRycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW1ib2wiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnR5IiwiYWxsUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eU5hbWUiLCJjbG9uZVByb3RvdHlwZSIsImMiLCJfX29ialRvU3RyIiwibyIsInRvU3RyaW5nIiwiY2FsbCIsInJlIiwiZmxhZ3MiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/clone/clone.js\n");

/***/ })

};
;